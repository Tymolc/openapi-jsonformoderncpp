{{#models}}{{#model}}#ifndef {{modelHeaderGuardPrefix}}_{{classname}}_H_
#define {{modelHeaderGuardPrefix}}_{{classname}}_H_

#include "serialization.h"

{{#hasOptional}}#include <optional>
{{/hasOptional}}

{{#imports}}{{{this}}}
{{/imports}}

{{! ---------------------------------------------------------------------- }}
{{! the model struct }}
{{! ---------------------------------------------------------------------- }}

{{#modelNamespaceDeclarations}}
namespace {{this}} {
{{/modelNamespaceDeclarations}}

{{#description}}/**
 * \brief {{description}}
{{#example}} *
 * Example: {{example}}
{{/example}}
 */
{{/description}}
struct {{classname}} {
    static const char *dtoName() { return "swagger::dto::{{classname}}"; }

{{#hasEnums}}    // enums
{{#vars}}{{#isEnum}}{{#description}}    /**
     * \brief {{description}}
     */
{{/description}}
    enum class {{enumName}} {
{{#allowableValues}}{{#enumVars}}        {{name}},
{{/enumVars}}{{/allowableValues}}    };
{{/isEnum}}
{{/vars}}
{{/hasEnums}}

{{#hasRequired}}    // required fields
{{#requiredVars}}
{{^isEnum}}    {{{datatype}}} {{baseName}};
{{/isEnum}}
{{#isEnum}}    {{enumName}} {{baseName}};
{{/isEnum}}
{{/requiredVars}}
{{/hasRequired}}

{{#hasOptional}}    // optional fields
{{#optionalVars}}
{{^isEnum}}    std::optional<{{{datatype}}}> {{baseName}};
{{/isEnum}}
{{#isEnum}}    std::optional<{{enumName}}> {{baseName}};
{{/isEnum}}
{{/optionalVars}}
{{/hasOptional}}
};

{{#modelNamespaceDeclarations}}
}  // namespace {{this}}
{{/modelNamespaceDeclarations}}

{{! ---------------------------------------------------------------------- }}
{{! adl_serializer specializations for enums in this model }}
{{! ---------------------------------------------------------------------- }}

{{#hasEnums}}
{{! adl_serializer specializations need to live in nlohmann namespace }}
namespace nlohmann {

{{#vars}}
{{#isEnum}}
template<>
struct adl_serializer<{{#modelNamespaceDeclarations}}{{this}}::{{/modelNamespaceDeclarations}}{{classname}}::{{enumName}}> {
  private:
    using {{classname}} = {{#modelNamespaceDeclarations}}{{this}}::{{/modelNamespaceDeclarations}}{{classname}};

  public:
    static void to_json(json& j, const {{classname}}::{{enumName}}& value) {
        switch (value) {
{{#allowableValues}}
{{#enumVars}}
        case {{classname}}::{{enumName}}::{{name}}:
            j = "{{name}}";
            return;
{{/enumVars}}
{{/allowableValues}}
        }
        UNREACHABLE_CODE
    }

    static void from_json(const json& j, {{classname}}::{{enumName}}& value) {
        auto s = j.get_ref<const json::string_t&>();
{{#allowableValues}}
{{#enumVars}}
        if (s == "{{name}}") {
            value = {{classname}}::{{enumName}}::{{name}};
            return;
        }
{{/enumVars}}
{{/allowableValues}}

        throw {{#modelNamespaceDeclarations}}{{this}}::{{/modelNamespaceDeclarations}}invalid_enum_value(s);
    }
};

{{/isEnum}}
{{/vars}}
} // namespace nlohmann
{{/hasEnums}}

{{! ---------------------------------------------------------------------- }}
{{! to_json and from_json for all fields in this model }}
{{! ---------------------------------------------------------------------- }}

{{! to_ and from_json need to live in the model namespace }}
{{! define them after the adl_serializer specialization they will use, though }}
{{#modelNamespaceDeclarations}}
namespace {{this}} {
{{/modelNamespaceDeclarations}}

void to_json(nlohmann::json& j, const {{classname}}& obj) {
    j = nlohmann::json{
{{#vars}}        {"{{baseName}}", obj.{{baseName}}},
{{/vars}}
    };
}

void from_json(const nlohmann::json& j, {{classname}}& obj) {
{{#requiredVars}}    j.at("{{baseName}}").get_to(obj.{{baseName}});
{{/requiredVars}}
{{#optionalVars}}    detail::to_optional(j, "{{baseName}}", obj.{{baseName}});
{{/optionalVars}}
}

{{#modelNamespaceDeclarations}}
}  // namespace {{this}}
{{/modelNamespaceDeclarations}}


#endif /* {{modelHeaderGuardPrefix}}_{{classname}}_H_ */
{{/model}}
{{/models}}
